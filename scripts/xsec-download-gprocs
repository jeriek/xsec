#!/usr/bin/env python

"""
Simple script for downloading trained Gaussian Processes
for use with the cross-section evaluation code.
Compatible with Python 2 and 3.

Usage:
    xsec-download-gprocs <directory-for-xsec-data>
    If no argument <directory-for-xsec-data> is given, the current
    working directory is used.
"""


from __future__ import print_function

import os
import sys
import time
import errno
import tarfile
import argparse


try:  # if python3
    from urllib.request import urlretrieve
except ImportError:  # if python2
    from urllib import urlretrieve

# Import xsec, first assume we have pip installed it
try:
    import xsec
# Someone is insisting on using our fine programme without pip
# installing
except ImportError:
    # Our current absolute directory
    absdir = os.path.dirname(os.path.abspath(__file__))
    # Parent directory containing xsec
    parent_dir = os.path.dirname(absdir)
    sys.path.append(parent_dir)
    import xsec

# Find current version number for correct download
VERSION = xsec.__version__

# Each download is specified as a (url, file_name) tuple in this list.
DOWNLOAD_LIST = [
    (
        "https://github.com/jeriek/xstest/releases/download/" + VERSION + "/"
        "xsec-gprocs-" + VERSION + ".tar.gz",
        "xsec-gprocs-" + VERSION + ".tar.gz",
    )
]


def main():
    """
    Download all files in DOWNLOAD_LIST.
    """

    # Get the script name
    prog_name = "xsec-download-gprocs"

    # Set up the argument parser
    parser = argparse.ArgumentParser(
        prog=prog_name,
        description="Tool for downloading Gaussian process files for xsec"
    )

    # Take the download directory as an optional argument
    parser.add_argument(
        "xsec_data_dir",
        nargs="?",
        metavar="PATH",
        type=str,
        action="store",
        default=os.path.join(os.getcwd(), "gprocs"),
        help="set the path where the downloaded files are stored. "
             "The default path is %(default)s.",
    )

    # Parse the arguments
    args = parser.parse_args()

    data_init_filepath = os.path.join(args.xsec_data_dir, "__init__.py")

    # Create data dir and/or init file if not existing
    if not os.path.exists(args.xsec_data_dir):
        try:
            # Create gprocs directory and empty init file
            mkdir_p(args.xsec_data_dir)
            open(data_init_filepath, "a").close()
        except OSError:
            raise
    elif not os.path.exists(data_init_filepath):
        try:
            # Create empty init file
            open(data_init_filepath, "a").close()
        except OSError:
            raise
        except IOError as exc:
            if exc.errno == errno.EACCES:
                print(
                    "Permission denied when trying to write the "
                    "file {f}. Do you have write permission for the "
                    "directory {dir}?".format(
                        f=data_init_filepath,
                        dir=args.xsec_data_dir
                    )
                )
                print()
                raise
            else:
                raise

    # Print a new line
    print()

    for url, file_name in DOWNLOAD_LIST:
        print("-- Downloading file", file_name, "from\n", url, ":\n")
        # Force writing to terminal; otherwise stdout is buffered first
        sys.stdout.flush()

        # Download compressed file to a temporary location (since
        # filename=None)
        try:
            tmp_filename, _ = urlretrieve(
                url, filename=None, reporthook=download_progress_hook
            )
        except IOError:
            print(
                "Download failed. Are you sure you're connected to "
                "the internet?"
            )
            print()
            raise

        print("\n\n  ... download completed")
        print("  ... starting file extraction (", tmp_filename, ")")
        sys.stdout.flush()
        tar = tarfile.open(tmp_filename, "r:gz")
        tar.extractall(args.xsec_data_dir)
        tar.close()
        print("  ... file extraction completed.")
        sys.stdout.flush()

    print()
    print(
        "All downloads completed. Data files stored in", args.xsec_data_dir,
        "\b."
    )
    print()


def mkdir_p(path):
    """
    Safely make new directories recursively, as with "mkdir -p".
    """
    try:
        os.makedirs(path)
    except OSError as exc:  # Python >2.5
        if exc.errno == errno.EEXIST and os.path.isdir(path):
            pass
        else:
            raise


def download_progress_hook(count, block_size, total_size):
    """
    Visualise download progress.
    Used with the urllib.urlretrieve reporthook.
    """

    # Compute time since start of download
    global start_time
    if count == 0:
        start_time = time.time()
        return
    duration = time.time() - start_time
    # Compute combined size of downloaded chunks, given in MB
    progress_size = float(count * block_size)
    # Compute download speed in KB/s
    speed = int(progress_size / (1024.0 * duration))

    # When the HTTP response has 'Content-Length' in the header, display
    # progress bar and percentage of download completion. Else, when
    # 'Transfer-Encoding: chunked' is used in the header, no information
    # about total size is available, so only display accumulated
    # download size.
    if total_size > 0:
        percent = min(int(count * block_size * 100 / total_size), 100)
        # Setup toolbar
        toolbar_width = 18
        progress_symbol = "/"
        n_progress_lines = int(percent * toolbar_width / 100.0)

        # Output to screen: progress bar, some useful info
        # (\r returns cursor to start of line to overwrite old info,
        # \b backspace, \t tab)
        sys.stdout.write(
            "\r[%s] \t\b\b %s%%  --  %.1f MB, %.1f s, %d KB/s"
            % (
                progress_symbol * n_progress_lines
                + " " * (toolbar_width - n_progress_lines),
                percent,
                progress_size / (1024.0 * 1024.0),
                duration,
                speed,
            )
        )
        # Force writing to terminal; otherwise stdout is buffered first
        sys.stdout.flush()

    else:
        sys.stdout.write(
            "\r  ... downloaded %.1f MB in %.1f s, avg speed: %d KB/s"
            % (progress_size / (1024.0 * 1024.0), duration, speed)
        )
        sys.stdout.flush()


# When the code is executed as a script, run the following.
if __name__ == "__main__":
    main()
